<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Home">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Home">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="可乐">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Home" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Home</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-computer-system-一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/26/computer-system-%E4%B8%80/" class="article-date">
  <time datetime="2020-04-25T17:10:24.000Z" itemprop="datePublished">2020-04-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Computer-System/">Computer System</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/26/computer-system-%E4%B8%80/">computer system(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="计算机系统漫游"><a href="#计算机系统漫游" class="headerlink" title="计算机系统漫游"></a>计算机系统漫游</h2><h4 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h4><h5 id="1-总线"><a href="#1-总线" class="headerlink" title="1. 总线"></a>1. 总线</h5><p>贯穿整个系统的是一组电子管道，称作总线，它携带字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块（Word），字长是一个基本的系统参数，各个系统中都不尽相同。现在大多数的机器字长要么是4字节,要么是8字节。</p>
<h5 id="2-I-O设备"><a href="#2-I-O设备" class="headerlink" title="2. I/O设备"></a>2. I/O设备</h5><p>I/O设备是系统与外部世界的联系通道（键盘、鼠标、显示器、磁盘等）。每个I/O设备都通过一个控制器或适配器与I/O总线相连。控制器与适配器的区别主要在于它们的封装方式。控制器是I/O设备本身或者系统的主印制电路板（通常称作主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。</p>
<h5 id="3-主存"><a href="#3-主存" class="headerlink" title="3. 主存"></a>3. 主存</h5><p>主存是一个临时存储设备。物理上来说，主存是由一组动态随机存取存储器（DRAM)芯片组成。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引）</p>
<h5 id="4-处理器"><a href="#4-处理器" class="headerlink" title="4. 处理器"></a>4. 处理器</h5><p>是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器。在任何时刻，程序计数器都指向主存中的某条机器语言指令（即含有该条指令的地址）。</p>
<p>CPU在指令的要求下可能会执行以下操作：</p>
<ul>
<li><p>加载： 从主存复制一个字节或一个字到寄存器，以覆盖寄存器原来的内容</p>
</li>
<li><p>存储： 从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。</p>
</li>
<li><p>操作： 把两个寄存器的内容复制到算术/逻辑单元（ALU)，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。</p>
</li>
<li><p>跳转 从指令本身中抽取一个字，并将这个字复制到程序计数器中，以覆盖程序计数器中原来的值</p>
</li>
</ul>
<h5 id="5-高速缓存至关重要"><a href="#5-高速缓存至关重要" class="headerlink" title="5. 高速缓存至关重要"></a>5. 高速缓存至关重要</h5><p>针对处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为高速缓存存储器，作为暂时的集结区域，存放处理器近期可能会需要的信息。高速缓存使用的是一种叫做静态随机访问存储器（SRAM)的硬件技术实现的。系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。</p>
<h5 id="6-存储设备形成层次结构"><a href="#6-存储设备形成层次结构" class="headerlink" title="6. 存储设备形成层次结构"></a>6. 存储设备形成层次结构</h5><p>存储器层次结构的主要思想是上一层存储器作为低一层存储器的高速缓存。</p>
<h4 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h4><p>当我们加载和运行程序时，程序都没有直接访问键盘、显示器、磁盘或者主存。取而代之的是他们依靠操作系统提供的服务。我们可以把操作系统看成是应用程序和硬件插入的一层软件。所有应用程序对硬件的操作尝试都必须通过操作系统。</p>
<p>操作系统有两个基本功能：（1） 防止硬件被失控的应用程序滥用。（2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。</p>
<p>操作系统通过几个基本的抽象概念来实现这两个功能。文件是I/O设备的抽象表示，虚拟内存是对主存和磁盘I/O设备的抽象表示，进程则是对处理器、主存和I/O设备的抽象表示。</p>
<h5 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h5><p>程序看上去是独占地使用处理器、主存和I/O设备。处理器看上去就像在不间断地一条一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。这些假象是通过进程来实现的。</p>
<p>进程是操作系统对一个正在运行的程序的一种抽象。无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为上下文切换。</p>
<p>操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。</p>
<p>从一个进程到另一个进程之间的转换，是操作系统内核管理的，内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的系统调用指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。</p>
<h5 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h5><p>一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。多线程之间比多进程之间更容易共享数据，线程一般来说都比进程更高效。</p>
<h5 id="3-虚拟内存"><a href="#3-虚拟内存" class="headerlink" title="3. 虚拟内存"></a>3. 虚拟内存</h5><p>虚拟内存是一个抽象，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。</p>
<p>每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。</p>
<ul>
<li>程序代码和数据</li>
</ul>
<p>对所有进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。代码和数据区在进程一开始运行时就被指定了大小。</p>
<ul>
<li>堆</li>
</ul>
<p>代码和数据区后紧随着是运行时堆。堆可在进程运行时动态地扩展和收缩。</p>
<ul>
<li>共享库</li>
</ul>
<p>大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。</p>
<ul>
<li>栈</li>
</ul>
<p>位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，可以在程序执行期间动态扩展和收缩</p>
<ul>
<li>内核虚拟内存</li>
</ul>
<p>地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或直接调用内核代码定义的函数。它们必须调用内核来执行这些操作</p>
<blockquote>
<p>虚拟内存运作的基本思想是：把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。</p>
</blockquote>
<h5 id="4-文件"><a href="#4-文件" class="headerlink" title="4. 文件"></a>4. 文件</h5><p>文件就是字节序列，仅此而已。每个I/O设备，包括磁盘、键盘、显示器，甚至是网络都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为Unix I/O的系统函数调用读写文件来实现的。它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的I/O设备。</p>
<h4 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h4><h5 id="1-线程级并发"><a href="#1-线程级并发" class="headerlink" title="1. 线程级并发"></a>1. 线程级并发</h5><p>传统意义上，并发执行只是模拟出来的。是通过使计算机在它正在执行的进程间快速切换来实现的。</p>
<p>超线程，有时称为同时多线程，是一项允许一个CPU执行多个控制流的技术。它涉及CPU某些硬件有多个备份，比如程序计数器和寄存器文件，而其他的硬件部分只有一份。</p>
<p>常规的处理器需要大约20000个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。这使得CPU能够更好地利用它的处理资源。比如，假设一个线程必须等到某些数据被装载到高速缓存中，那CPU就可以继续去执行另一个线程。</p>
<p>多处理器可以从两个方面来提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要。其次，它可以使应用程序运行得更快，当然这必须要求程序是以多线程方式来书写的，这些线程可以并行地高效执行。</p>
<h5 id="2-指令级并行"><a href="#2-指令级并行" class="headerlink" title="2. 指令级并行"></a>2. 指令级并行</h5><p>在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。早期的微处理器，需要多个（通常是3<del>10个）时钟周期来执行一条指令。最近的处理器可以保持每个时钟周期2</del>4条指令的执行效率。其实每条指令从开始到结束需要长得多的时间，大约20个或更多周期。</p>
<p>如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为超标量处理器。</p>
<h5 id="3-单指令、多数据并行"><a href="#3-单指令、多数据并行" class="headerlink" title="3. 单指令、多数据并行"></a>3. 单指令、多数据并行</h5><p>在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据并行。即SIMD并行。</p>
<p>提供这些SIMD指令多是为了提高处理影像、声音和视频数据应用的执行速度。虽然有些编译器会试图从C程序中自动抽取SIMD并行性，但是更可靠的方法是用编译器支持的特殊的向量数据类型来写程序。</p>
<h2 id="程序结构和执行"><a href="#程序结构和执行" class="headerlink" title="程序结构和执行"></a>程序结构和执行</h2><h3 id="信息的表示和处理"><a href="#信息的表示和处理" class="headerlink" title="信息的表示和处理"></a>信息的表示和处理</h3><p>无符号编码基于传统的二进制表示法，表示大于或等于零的数字。补码编码是表示有符号整数的最常见的方式。浮点数编码是表示实数的科学技术法以2为基数的版本。</p>
<p>浮点运算是不可结合的。例如，在大多数机器上，C表达式（3.14 + 1e20) - 1e20求得的值会是0，而3.14 + (1e20 - 1e20)求得的值会是3.14.</p>
<h4 id="1-信息的存储"><a href="#1-信息的存储" class="headerlink" title="1. 信息的存储"></a>1. 信息的存储</h4><p>大多数计算机使用8位的块，或者字节，作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存，所有可能地址的集合就称为虚拟地址空间。</p>
<h4 id="2-十六进制表示法"><a href="#2-十六进制表示法" class="headerlink" title="2. 十六进制表示法"></a>2. 十六进制表示法</h4><p>当x是2的非负整数n次幂时，也就是x=2<sup>n</sup>, 可以很容易的把它写成十六进制的形式，只要记住x的二进制表示就是1后面跟n个0，当n表示成i + 4j的形式，其中0 ≤ i ≤ 3，我们可以把x写成开头的十六进制数字为1（i = 0),2(i = 1), 4(i = 2), 8(i = 3),后面跟着j个十六进制的0。比如，x=2048=2<sup>11</sup>,n= 11= 3 +4*2，从而得到十六进制表示0x800.</p>
<h4 id="2-字数据大小"><a href="#2-字数据大小" class="headerlink" title="2. 字数据大小"></a>2. 字数据大小</h4><p>每台计算机都有一个字长，指明指针数据的标称大小。虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。</p>
<p>大部分数据类型都编码为有符号数值，除非有前缀unsigned或对确定大小的数据类型使用了特定的无符号声明。数据类型char是一个例外。尽管大多数编译器和机器将他们视为有符号数，但C标准不保证这一点。</p>
<h4 id="3-寻址和字节顺序"><a href="#3-寻址和字节顺序" class="headerlink" title="3. 寻址和字节顺序"></a>3. 寻址和字节顺序</h4><p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。</p>
<ul>
<li><p>大端法： 最高有效字节在最前面的方式</p>
</li>
<li><p>小端法： 最低有效字节在最前面的方式</p>
</li>
</ul>
<p>需要注意大小端的几个场合：</p>
<ul>
<li><p>在不同类型的机器之间通过网络传送二进制数据时。</p>
</li>
<li><p>检查机器级程序时，阅读表示整数数据的字节序列时字节顺序。</p>
</li>
<li><p>当编写规避正常的类型系统的程序时。在C语言中可以通过强制类型转换（cast)或联合（union)来允许以一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看机器大小端代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bytes</span><span class="params">(byte_pointer start, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %.2x&quot;</span>, start[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_int</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    show_bytes((byte_pointer)&amp;x, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_float</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">    show_bytes((byte_pointer)&amp;x, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_pointer</span><span class="params">(<span class="keyword">void</span> *x)</span> </span>&#123;</span><br><span class="line">    show_bytes((byte_pointer)&amp;x, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_show_bytes</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ival = val;</span><br><span class="line">    <span class="keyword">float</span> fval = (<span class="keyword">float</span>)ival;</span><br><span class="line">    <span class="keyword">int</span> *pVal = &amp;ival;</span><br><span class="line">    show_int(ival);</span><br><span class="line">    show_float(fval);</span><br><span class="line">    show_pointer(pVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ival = <span class="number">12345</span>;</span><br><span class="line">    <span class="comment">// show_int(ival);</span></span><br><span class="line">    test_show_bytes(ival);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码int和float在不同机器或操作系统结果是相同的，只是字节顺序不同。但是指针却是完全不同的。不同机器/操作系统配置使用不同的存储分配规则。</p>
</blockquote>
<h4 id="4-表示字符串"><a href="#4-表示字符串" class="headerlink" title="4. 表示字符串"></a>4. 表示字符串</h4><p>文本数据比二进制数据具有更强的平台独立性。java编程语言使用Unicode来表示字符串。</p>
<h4 id="5-布尔代数简介"><a href="#5-布尔代数简介" class="headerlink" title="5. 布尔代数简介"></a>5. 布尔代数简介</h4><p>位向量就是固定长度为w，由0和1组成的串。</p>
<p>位向量有一个很有用的应用就是表示有限集合。我们可以用位向量[a<sub>w-1</sub>, …, a<sub>1</sub>, a<sub>0</sub>]来表示集合。例如位向量a = [01101001] 表示集合A= {0, 3, 5, 6},而b = [01010101]表示集合B = {0, 2, 4, 6},使用这种编码集合的方法，布尔运算|和&amp;分别对应于集合的并和交，而~对应于集合的补。运算a&amp;b = [01000001], 而A 交 B = {0, 6}.</p>
<h4 id="6-C语言中的移位运算"><a href="#6-C语言中的移位运算" class="headerlink" title="6. C语言中的移位运算"></a>6. C语言中的移位运算</h4><p>机器支持两种形式的右移：逻辑右移和算术右移。逻辑右移在左端补0，算术右移在左端补k个最高有效位的值。</p>
<blockquote>
<p>C语言标准没有明确定义对于有符号数应该使用哪种类型的右移。但是实际上几乎所有的编译器/机器组合都对有符号数使用算术右移，对于无符号数使用逻辑右移。</p>
</blockquote>
<p>与C相比，java对于如何进行右移有明确的定义。表达式x&gt;&gt;k会将x算术右移k个位置，而x&gt;&gt;&gt;k会对x做逻辑右移。</p>
<p>当移动k位，这里k很大时，对于一个由w位组成的数据类型，如果要移动k≥w位会得到什么结果呢？例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lval = <span class="number">0xFEDCBA98</span> &lt;&lt; <span class="number">32</span>;</span><br><span class="line"><span class="keyword">int</span> aval = <span class="number">0xFEDCBA98</span> &gt;&gt; <span class="number">36</span>;</span><br><span class="line"><span class="keyword">unsigned</span> uval = <span class="number">0xFEDCBA98</span>u &gt;&gt; <span class="number">40</span>;</span><br></pre></td></tr></table></figure>

<p>在许多机器上，当移动一个w位的值时，移位指令只考虑位移量的低log<sub>2</sub>w位。因此实际上位移量就是通过计算k mod w得到的。例如当w = 32时，上面三个移位运算分别是移动0，4，8位。不过这种行为对于C程序来说是没有保证的，所以应该保持位移量小于待移位值的位数。另一方面，java特别要求位移数量应该按照我们前面所讲的求模的方法来计算。</p>
<h4 id="7-整型数据类型"><a href="#7-整型数据类型" class="headerlink" title="7. 整型数据类型"></a>7. 整型数据类型</h4><p>C和C++都支持有符号（默认）和无符号数。Java只支持有符号数</p>
<blockquote>
<p>C语言标准并没有要求要用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的。</p>
</blockquote>
<h4 id="6-有符号数和无符号数之间的转换"><a href="#6-有符号数和无符号数之间的转换" class="headerlink" title="6. 有符号数和无符号数之间的转换"></a>6. 有符号数和无符号数之间的转换</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> v = <span class="number">-12345</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> uv = (<span class="keyword">unsigned</span> <span class="keyword">short</span>)v;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;v = %d, uv = %u\n&quot;</span>, v, uv);</span><br><span class="line"><span class="comment">// 输出：v = -12345 uv = 53191</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。</p>
</blockquote>
<p>对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一搬规则是：数值可能被改变，但是位模式不变。</p>
<p>C语言中当声明一个像12345或者0x1A2B这样的常量时，这个值就被认为是有符号的。要创建一个无符号常量，必须加上后缀字符’U’或者‘u’.</p>
<p>C语言允许无符号数和有符号数的转换，虽然C标准没有精确规定应如何进行这种转换，但大多数系统遵循的原则是底层的位表示保持不变。</p>
<p>C语言中，当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。这种方法对于标准的算术运算来说并无多大差异，但是对于像&lt;和&gt;这样的关系运算符来说，它会导致非直观的结果。</p>
<h4 id="7-扩展一个数字的位表示"><a href="#7-扩展一个数字的位表示" class="headerlink" title="7. 扩展一个数字的位表示"></a>7. 扩展一个数字的位表示</h4><p>要将一个无符号数转换为一个更大的数据类型，我们只要简单地在表示的开头添加0.这种运算被称为0扩展。</p>
<h3 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h3><p>计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。</p>
<h4 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h4><p>对于机器级编程来说，其中两种抽象尤为重要。一种是由指令集体系结构或指令集架构来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数指令集体系结构，将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条再开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与指令集体系结构指定的顺序行为的行为完全一致。第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。</p>
<ul>
<li><p>程序计数器（通常称为“PC”， 在x86-64中用%rip表示）给出将要执行的下一条指令在内存中的地址</p>
</li>
<li><p>整数寄存器文件包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址（对应于C语言的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。</p>
</li>
<li><p>条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现if和while语句</p>
</li>
<li><p>一组向量寄存器可以存放一个或多个整数或浮点数值。</p>
</li>
</ul>
<p>虽然C语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单地将内存看成一个很大的、按字节寻址的数组。C语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节来表示。即使是对标量数据类型，汇编代码也不区分有符号或无符号整数，不区分各种类型的指针，甚至不区分指针和整数。</p>
<p>程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块。操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。</p>
<p>GCC编译器将C编译成汇编代码指令：</p>
<blockquote>
<p>gcc -Og -S xxx.c</p>
</blockquote>
<p>GCC编译器编译汇编代码：</p>
<blockquote>
<p>gcc -Og -c xx</p>
</blockquote>
<p>下查看机器代码文件的内容，反汇编器非常有用。Linux下使用：</p>
<blockquote>
<p>objdump -d mstore.o</p>
</blockquote>
<ul>
<li>x86-64的指令长度从1到15个字节不等。常用的指令以及操作数较少的指令所需字节数少，而不太常用或操作数较多的指令所需的字节数较多</li>
<li>设计指令的方式是，从某个指定位置开始，可以将字节唯一地解码成机器指令。</li>
</ul>
<p>生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个main函数。</p>
<h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><p>由于是从16位体系结构扩展成32位的，Intel用术语“字（word)”表示16位数据类型。因此，成32位数为“双字“，称64位数为”四字“。</p>
<p>C语言基本类型对应的x86-64表示：</p>
<table>
<thead>
<tr>
<th align="left">C声明</th>
<th align="left">Intel数据类型</th>
<th align="left">汇编代码后缀</th>
<th align="left">大小（字节）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">char</td>
<td align="left">字节</td>
<td align="left">b</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">字</td>
<td align="left">w</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">双字</td>
<td align="left">l</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">四字</td>
<td align="left">q</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">char*</td>
<td align="left">四字</td>
<td align="left">q</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">单精度</td>
<td align="left">s</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">双精度</td>
<td align="left">l</td>
<td align="left">8</td>
</tr>
</tbody></table>
<h4 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h4><p>一个x86-64的中央处理单元（CPU) 包含一组16个存储64位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。</p>
<p>对于生成小于8字节结果的指令，寄存器中剩下的字节会怎样，对此有两条规则：生成1字节和2字节数字的指令会保持剩下的字节不变；生成四字节数字的指令会把高四位4个字节置为0.</p>
<h4 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h4><p>大多数指令有一个或多个操作数，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。</p>
<p>源数据值可以以常数形式给出，或是从寄存器或内存中读出。结果可以放在寄存器或内存中。因此各种不同的操作数的可能性被分为三种类型，第一种类型是立即数，用来表示常数值。在ATT格式的汇编代码中，立即数的书写方式是‘$’后面跟一个整数。第二种类型是寄存器，R[r<sub>a</sub>]来表示某个寄存器的值。第三类操作数是内存引用，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。我们用符号M<sub>b</sub>[Addr]表示对存储在内存中从地址Addr开始的b个字节值的引用。</p>
<h4 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h4><h5 id="MOV类-把数据从源位置复制到目的位置"><a href="#MOV类-把数据从源位置复制到目的位置" class="headerlink" title="MOV类 把数据从源位置复制到目的位置"></a>MOV类 把数据从源位置复制到目的位置</h5><table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">效果</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">MOV S,D</td>
<td align="left">D ← S</td>
<td align="left">传送</td>
</tr>
<tr>
<td align="left">movb</td>
<td align="left"></td>
<td align="left">传送字节</td>
</tr>
<tr>
<td align="left">movw</td>
<td align="left"></td>
<td align="left">传送字</td>
</tr>
<tr>
<td align="left">movl</td>
<td align="left"></td>
<td align="left">传送双字</td>
</tr>
<tr>
<td align="left">movq</td>
<td align="left"></td>
<td align="left">传送四字</td>
</tr>
<tr>
<td align="left">movabsq I,R</td>
<td align="left">R ← I</td>
<td align="left">传送绝对的四字</td>
</tr>
</tbody></table>
<p>源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数制定一个位置，要么是一个寄存器，要么是一个内存地址。x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令——第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。</p>
<p>MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是movl指令以寄存器作为目的时，它会把该寄存器的高位四字节设置为0.</p>
<blockquote>
<p>movabsq是处理64位立即数数据的，常规的movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展得到64位的值，放到目的位置。movabsq指令能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的。</p>
</blockquote>
<p>下面两个表中是将较小的源值复制到较大的目的时使用。所有的这些指令都是把数据从源（在寄存器或内存中）复制到目的寄存器。</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">效果</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">MOVZ S,R</td>
<td align="left">R ← 零扩展(S)</td>
<td align="left">以零扩展进行传送</td>
</tr>
<tr>
<td align="left">movzbw</td>
<td align="left"></td>
<td align="left">将做了零扩展的字节传送到字</td>
</tr>
<tr>
<td align="left">movzbl</td>
<td align="left"></td>
<td align="left">将做了零扩展的字节传送到双字</td>
</tr>
<tr>
<td align="left">movzwl</td>
<td align="left"></td>
<td align="left">将做了零扩展的字传送到双字</td>
</tr>
<tr>
<td align="left">movzbq</td>
<td align="left"></td>
<td align="left">将做了零扩展的字节传送到四字</td>
</tr>
<tr>
<td align="left">movzwq</td>
<td align="left"></td>
<td align="left">将做了零扩展的字传送到四字</td>
</tr>
</tbody></table>
<blockquote>
<p>注意上述表格内没有明确的指令把4字节源值零扩展到8字节目的，这样的指令逻辑上应该被命名为movzlq,但是并没有这样的指令。不过这样的传送可以用以寄存器为目的的movl指令来实现。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">效果</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">MOVS S,R</td>
<td align="left">R ← 符号扩展（S)</td>
<td align="left">传送符号扩展的字节</td>
</tr>
<tr>
<td align="left">movsbw</td>
<td align="left"></td>
<td align="left">将做了符号扩展的字节传送到字</td>
</tr>
<tr>
<td align="left">movsbl</td>
<td align="left"></td>
<td align="left">将做了符号扩展的字节传送到双字</td>
</tr>
<tr>
<td align="left">movswl</td>
<td align="left"></td>
<td align="left">将做了符号扩展的字传送到双字</td>
</tr>
<tr>
<td align="left">movsbq</td>
<td align="left"></td>
<td align="left">将做了符号扩展的字节传送到四字</td>
</tr>
<tr>
<td align="left">movswq</td>
<td align="left"></td>
<td align="left">将做了符号扩展的字传送到四字</td>
</tr>
<tr>
<td align="left">movslq</td>
<td align="left"></td>
<td align="left">将做了符号扩展的双字传送到四字</td>
</tr>
<tr>
<td align="left">cltq</td>
<td align="left">%rax ← 符号扩展（%eax)</td>
<td align="left">把%eax符号扩展到%rax</td>
</tr>
</tbody></table>
<h4 id="数据传送示例"><a href="#数据传送示例" class="headerlink" title="数据传送示例"></a>数据传送示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">exchange</span><span class="params">(<span class="keyword">long</span> *xp, <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> x = *xp;</span><br><span class="line">    *xp = y;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// xp in %rdi, <span class="keyword">y</span> in %rsi</span><br><span class="line">exchange:</span><br><span class="line"> mov<span class="string">q (%rdi)</span>, %rax             获取xp值保存在%rax(返回值)</span><br><span class="line"> movq %rsi, (%rdi)             保存<span class="keyword">y</span>到xp指向的地址</span><br><span class="line"> ret                           返回（%rax内保存着返回值）</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于这段汇编代码有两点值得注意。首先，C语言中的指针其实就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。其次，像x这样的局部变量通常是保存在寄存器中，而不是内存中。</p>
</blockquote>
<h4 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h4><p>栈遵循“后进先出”的原则，弹出的值永远是最近被压入而且仍然在栈中的值。在x86-64中，程序栈存放在内存中某个区域。栈向下增长，栈顶元素的地址时所有栈中元素地址中最低的。栈指针%rsp保存着栈顶元素的地址。</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">效果</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">pushq S</td>
<td align="left">R[%rsp]←R[%rsp] -8; M[R[%rsp]] ← S</td>
<td align="left">将四字节入栈</td>
</tr>
<tr>
<td align="left">popq D</td>
<td align="left">D ← M[R[%rsp]]; R[%rsp] ← R[%rsp] + 8</td>
<td align="left">将四字节出栈</td>
</tr>
</tbody></table>
<h3 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h3><table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">效果</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">leaq S,D</td>
<td align="left">D ← &amp;S</td>
<td align="left">加载有效地址</td>
</tr>
<tr>
<td align="left">INC D</td>
<td align="left">D ← D + 1</td>
<td align="left">加1</td>
</tr>
<tr>
<td align="left">DEC D</td>
<td align="left">D ← D - 1</td>
<td align="left">减1</td>
</tr>
<tr>
<td align="left">NEG D</td>
<td align="left">D ← -D</td>
<td align="left">取负</td>
</tr>
<tr>
<td align="left">NOT D</td>
<td align="left">D ← ~D</td>
<td align="left">取补</td>
</tr>
<tr>
<td align="left">ADD S,D</td>
<td align="left">D ← D + S</td>
<td align="left">加</td>
</tr>
<tr>
<td align="left">SUB S,D</td>
<td align="left">D ← D - S</td>
<td align="left">减</td>
</tr>
<tr>
<td align="left">IMUL S,D</td>
<td align="left">D ← D*S</td>
<td align="left">乘</td>
</tr>
<tr>
<td align="left">XOR S,D</td>
<td align="left">D ← D ^ S</td>
<td align="left">异或</td>
</tr>
<tr>
<td align="left">OR S,D</td>
<td align="left">D ← D | S</td>
<td align="left">或</td>
</tr>
<tr>
<td align="left">AND S,D</td>
<td align="left">D ← D &amp; S</td>
<td align="left">与</td>
</tr>
<tr>
<td align="left">SAL k,D</td>
<td align="left">D ← D &lt;&lt; k</td>
<td align="left">左移</td>
</tr>
<tr>
<td align="left">SHL k,D</td>
<td align="left">D ← D &lt;&lt; k</td>
<td align="left">左移(等同于SAL)</td>
</tr>
<tr>
<td align="left">SAR k,D</td>
<td align="left">D ← D &gt;&gt;<sub>A</sub>k</td>
<td align="left">算术右移</td>
</tr>
<tr>
<td align="left">SHR k,D</td>
<td align="left">D ← D &gt;&gt;<sub>L</sub>k</td>
<td align="left">逻辑右移</td>
</tr>
</tbody></table>
<p>以上这些指令除了leaq外，其他都有各种不同大小操作数的变种。例如，指令类ADD由四条加法指令组成：addb addw addl addq</p>
<h4 id="加载有效地址"><a href="#加载有效地址" class="headerlink" title="加载有效地址"></a>加载有效地址</h4><p>加载有效地址指令leaq实际上是movq指令的变形。它的指令形式是从内存读取数据到寄存器，但实际上它根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。目的操作数必须是一个寄存器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">scale</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y, <span class="keyword">long</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> t = x + <span class="number">4</span> * y + <span class="number">12</span> * z;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">x</span> in %rdi, <span class="keyword">y</span> in %rsi, z in %rdx</span><br><span class="line">scale:</span><br><span class="line">    lea<span class="string">q (%rdi, %rsi, 4)</span>, %rax</span><br><span class="line">    lea<span class="string">q (%rdx, %rdx, 2)</span>, %rdx</span><br><span class="line">    lea<span class="string">q (%rax, %rdx, 4)</span>, %rax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<h4 id="一元和二元操作"><a href="#一元和二元操作" class="headerlink" title="一元和二元操作"></a>一元和二元操作</h4><p>一元操作，只有一个操作数，既是源又是目的。这个操作数可以使一个寄存器，也可以是一个内存位置。</p>
<p>二元操作，第二个数既是源又是目的。类似于x-=y. 不过源操作数是第一个，目的操作数是第二个，第一个操作数可以是立即数、寄存器或内存位置。第二个操作可以是寄存器或内存位置。注意当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存。</p>
<h4 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h4><p>移位操作，先给出移位量，然后第二项是要移位的数。移位量可以是一个立即数，或者放在单字节寄存器%cl中（这些指令很特别，因为只允许以这个特定的寄存器作为操作数）。x86-64中，移位操作对w位长的数据值进行操作，移位量是由%c1寄存器的低m位决定的，这里2<sup>m</sup>=w。高位会被忽略。所以例如当寄存器%cl的值为0xFF时，指令salb会移7位，salw会移17位，sall会移31位，salq会移63位。</p>
<p>移位操作的目的操作数可以是一个寄存器或一个内存位置。</p>
<h4 id="特殊的算术操作"><a href="#特殊的算术操作" class="headerlink" title="特殊的算术操作"></a>特殊的算术操作</h4><p>两个64位有符号或无符号整数相乘得到的乘积需要128位来表示。下面描述的是支持产生两个64位数字的全128位乘积以及整数除法的指令</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">效果</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">imulq S</td>
<td align="left">R[%rdx]:R[%rax] ← S * R[%rax]</td>
<td align="left">有符号全乘法</td>
</tr>
<tr>
<td align="left">mulq S</td>
<td align="left">R[%rdx]:R[%rax] ← S * R[%rax]</td>
<td align="left">无符号全乘法</td>
</tr>
<tr>
<td align="left">clto</td>
<td align="left">R[%rdx]:R[%rax] ← 符号扩展（R[%rax]）</td>
<td align="left">转换为8字</td>
</tr>
<tr>
<td align="left">idivq S</td>
<td align="left">R[%rdx] ← R[%rdx]： R[%rax] ÷ S</td>
<td align="left">有符号除法</td>
</tr>
<tr>
<td align="left">divq S</td>
<td align="left">R[%rdx] ← R[%rdx]： R[%rax] ÷ S</td>
<td align="left">无符号除法</td>
</tr>
</tbody></table>
<blockquote>
<p>一对寄存器%rdx和%rax组成一个128位的8字</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/26/computer-system-%E4%B8%80/" data-id="ckpkyp28r0011hd3a242fadsm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-System/" rel="tag">Computer System</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-零散知识点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/28/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time datetime="2020-02-28T14:36:40.000Z" itemprop="datePublished">2020-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/28/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9/">零散知识点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="零散知识点"><a href="#零散知识点" class="headerlink" title="零散知识点"></a>零散知识点</h2><h3 id="1-explict-修饰构造函数"><a href="#1-explict-修饰构造函数" class="headerlink" title="1. explict 修饰构造函数"></a>1. explict 修饰构造函数</h3><p>可以阻止它们被用来执行隐式转换，但它们仍可被用来进行显式类型转换。</p>
<blockquote>
<p>除非有一个好理由允许构造函数被用于隐式类型转换，否则声明为explicit是好的选择。</p>
</blockquote>
<h3 id="2-对const常量取地址"><a href="#2-对const常量取地址" class="headerlink" title="2. 对const常量取地址"></a>2. 对const常量取地址</h3><p>对const常量取地址时，编译器会进行内存分配，并将常量转换为立即数存入内存，而不是存入记录在常量表中的地址。</p>
<p>在使用常量时，编译器回到常量表中查询对应的常量，并将其替换，这部分没有涉及内存分配，也跟曾经创建的常量的内存地址无关。</p>
<h3 id="3-mutable关键字"><a href="#3-mutable关键字" class="headerlink" title="3. mutable关键字"></a>3. mutable关键字</h3><p>mutable关键字可以突破const的限制。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTesxtBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">std::<span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">    <span class="keyword">mutable</span> std::<span class="keyword">size_t</span> textLength; <span class="comment">// 这些成员变量可能总是会被更改，</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> lengthIsValid; <span class="comment">// 即使在const成员函数内</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::<span class="keyword">size_t</span> <span class="title">CTextBlock::length</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!lengthIsValid) &#123;</span><br><span class="line">        textLength = std::<span class="built_in">strlen</span>(pText); <span class="comment">// 可以修改</span></span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-const-cast"><a href="#4-const-cast" class="headerlink" title="4. const_cast"></a>4. const_cast</h3><p>const_cast&lt;&gt; 可以移除对象的const属性</p>
<h3 id="5-extern"><a href="#5-extern" class="headerlink" title="5. extern"></a>5. extern</h3><p>extern 关键字有两个作用</p>
<ul>
<li><p>当它与“C”一起连用时，如：extern “C” void func(int a, int b);告诉编译器func这个函数名是按照C的规则去翻译相应的函数名而不是C++的，C++编译时会把func这个函数名变得面目全非，可能是func@abc_int_int也可能是别的（不同编译器不同），因为C++支持函数重载</p>
</li>
<li><p>在头文件中：extern int g_Int；它的作用就是声明全局变量或者函数的作用范围的关键字，其声明的函数和变量可以在本模块或其他模块中使用。记住它是一个声明不是定义。也就是B模块如果引用A模块中定义的全局变量或函数时，它只要包含A模块的头文件即可，在编译阶段，模块B虽然找不到该函数或变量，但他不会报错，它会在链接时从模块A生成的目标代码中找到此函数。</p>
</li>
</ul>
<h3 id="6-原码、反码、补码"><a href="#6-原码、反码、补码" class="headerlink" title="6. 原码、反码、补码"></a>6. 原码、反码、补码</h3><p>在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。</p>
<p>正整数的补码是其二进制表示，与原码相同。负整数的补码，将其原码除符号位外的所有位按位取反后加1.</p>
<h3 id="7-GDB调试"><a href="#7-GDB调试" class="headerlink" title="7 GDB调试"></a>7 GDB调试</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/daaikuaichuan/article/details/89791255">https://blog.csdn.net/daaikuaichuan/article/details/89791255</a></p>
<blockquote>
<p>数0的补码表示是唯一的。</p>
</blockquote>
<blockquote>
<p>[+0]补=[+0]反=[+0]原=00000000</p>
</blockquote>
<blockquote>
<p>[-0]补=11111111+1=00000000</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/28/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="ckpkyp28n000whd3acf5p6jmc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Effective-C-改善程序与设计的55个具体做法_all" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/07/Effective-C-%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95_all/" class="article-date">
  <time datetime="2020-01-06T16:02:37.000Z" itemprop="datePublished">2020-01-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/07/Effective-C-%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95_all/">Effective-C-改善程序与设计的55个具体做法(All)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Effective-C-改善程序与设计的55个具体做法"><a href="#Effective-C-改善程序与设计的55个具体做法" class="headerlink" title="Effective-C-改善程序与设计的55个具体做法"></a>Effective-C-改善程序与设计的55个具体做法</h4><ol>
<li>视C++为一个语言联邦</li>
<li>尽量以const，enum，inline替换#define</li>
<li>尽可能使用const</li>
<li>确定对象被使用前已被初始化</li>
<li>了解C++默默编写并调用哪些函数</li>
<li>若不想使用编译器自动生成的函数，就该明确拒绝</li>
<li>为多态基类使用virtual析构函数</li>
<li>别让异常逃离析构函数</li>
<li>绝不在构造函数和析构函数中调用virtual函数</li>
<li>令operator= 返回一个reference to *this</li>
<li>在operator= 中处理”自我赋值“</li>
<li>复制对象时勿忘记其每一个成分</li>
<li>以对象管理资源</li>
<li>在资源管理中小心copy行为</li>
<li>在资源管理类中提供对原始资源的访问</li>
<li>成对使用new和delete时要使用相同的形式</li>
<li>以独立语句将newed对象置入智能指针</li>
<li>让接口容易被正确使用，不易被误用</li>
<li>设计class犹如设计type</li>
<li>宁以pass-by-reference-to-const 替换pass-by-value</li>
<li>必须返回对象时，别妄想返回其reference</li>
<li>将成员变量声明为private</li>
<li>宁以non-member、non-friend替换member函数</li>
<li>若所有参数皆需类型转换，请为此采用non-member函数</li>
<li>考虑写出一个不抛异常的swap函数</li>
<li>尽可能延后变量定义式的出现时间</li>
<li>尽量少做转型动作</li>
<li>避免返回handles指向对象内部成分</li>
<li>为”异常安全“而努力是值得的</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/07/Effective-C-%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95_all/" data-id="ckpkyp2810007hd3a1acobehn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Effective-C/" rel="tag">Effective C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Effective-C-改善程序与设计的55个具体做法五-26-31" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/05/Effective-C-%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95%E4%BA%94-26-31/" class="article-date">
  <time datetime="2020-01-05T14:47:45.000Z" itemprop="datePublished">2020-01-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/05/Effective-C-%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95%E4%BA%94-26-31/">Effective-C-改善程序与设计的55个具体做法(五)(26~31)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="五-实现"><a href="#五-实现" class="headerlink" title="五. 实现"></a>五. 实现</h4><h5 id="26-尽可能延后变量定义式的出现时间"><a href="#26-尽可能延后变量定义式的出现时间" class="headerlink" title="26. 尽可能延后变量定义式的出现时间"></a>26. 尽可能延后变量定义式的出现时间</h5><p>尽量避免定义不使用的变量。或许你会认为，你不可能定义一个不使用的变量，但话不要说得太早！考虑如下的函数，它计算通行密码的加密版本而后返回，前提是密码够长。如果密码太短，函数会丢出一个异常，类型为logic_error：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="keyword">const</span> std::string&amp; password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    string encrypted;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">lenth</span>() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// 必要动作，将一个加密后的密码置入变量encrypted内。</span></span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象encrypted在此函数中并非完全未被使用，但如果有个异常被抛出，它就真的没被使用。最好延后它的定义式，直到确实需要他：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="keyword">const</span> std::string&amp; password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">if</span> (password.<span class="built_in">length</span>() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;Password is too short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    string encrypted;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码仍不够完美，因为encrypted虽获定义但并没有任何实参作为初值。这意味着调用的是其default构造函数。许多时候你该对对象做的第一次事就是给他个值，通常是通过一个赋值动作达成，但是他比直接在构造时指定初值效率差，最佳做法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">encryptPassword</span><span class="params">(<span class="keyword">const</span> string&amp; password)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">// 如前，检查length</span></span><br><span class="line">    <span class="function">std::string <span class="title">encrypted</span><span class="params">(password)</span></span>; <span class="comment">// 通过copy构造函数定义并初始化</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你不止应该延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给他初值实参为止。如果这样，不仅能够避免构造非必要对象，还可以避免无意义的default构造行为。</p>
<p>但是在遇到循环的时候该怎么办？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法A: 定义在循环外部：</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    w = 取决于i的某个值;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法B: 定义在循环的内部</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(取决于i的某个值)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种方法的成本：</p>
<ul>
<li>做法A: 1个构造函数 + 1个析构函数 + n个赋值操作</li>
<li>做法B: n个构造函数 + n个析构函数</li>
</ul>
<p>如果class的一个赋值成本低于一组构造+析构的成本，方法A一般比较高效。尤其当n值很大的时候。否则做法B或许比较好。</p>
<blockquote>
<ul>
<li>尽可能延后变量定义式的出现。这样做可以增加程序的清晰度并改善程序效率。</li>
</ul>
</blockquote>
<h5 id="27-尽量少做转型动作"><a href="#27-尽量少做转型动作" class="headerlink" title="27. 尽量少做转型动作"></a>27. 尽量少做转型动作</h5><p>C++规则的设计目标之一是，保证”类型错误“绝不可能发生。不幸的是，转型破坏了类型系统。</p>
<p>首先回顾转型语法，因为通常有3中不同的形式，C风格的转型动作看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(T)expression <span class="comment">// 将expression转型为T</span></span><br><span class="line"><span class="comment">// 函数风格的转型动作看起来像这样</span></span><br><span class="line"><span class="built_in">T</span>(expression)</span><br></pre></td></tr></table></figure>

<p>这两种形式并无差别，称为”旧式转型“</p>
<p>C++还提供四种转型（常被称为new-style或C++style casts):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="keyword">reinterpret_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="keyword">static_cast</span>&lt;T&gt;(expression)</span><br></pre></td></tr></table></figure>

<p>各有不同的目的：</p>
<ul>
<li>const_cast 通常是用来将对象的常量性转除，它也是唯一有此能力的C++ style转型操作符</li>
<li>dynamic_cast 主要用来执行”安全向下转型“，也就是用来决定某个对象是否归属继承体系中的某个类型。它是一个唯一一个无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。</li>
<li>reinterpret_cast 意图执行低级转型，实际动作（及结果）可能取决于编译器，这也就表示它不可移植。例如将一个pointer to int转型为一个int。这一类转型在低级代码以外很少见，是在讨论原始内存写出一个调试用的分配器时，见条款50.</li>
<li>static_cast 用来强迫隐式转换，例如将non-const对象转为const对象，或将int转为double等等。它也可以用来执行上述多种转换的反向转换，例如将void* 指针转为typed指针，将pointer-to-base转为pointer-to-derived.但无法将const转为non-const。</li>
</ul>
<p>许多程序员相信。转型其实什么都没做，只是告诉编译器把某种类型视为另一种类型。这是错误得观念。任何一种类型转换（不论是通过转型操作而进行的显示转换，或通过编译器完成的隐式转换）往往真的令编译器编译出运行期间执行的码，例如在这段程序中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">double</span> d = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x)/y; <span class="comment">// x除以y,使用浮点数除法</span></span><br></pre></td></tr></table></figure>

<p>将int x转换为double几乎肯定会产生一些代码，因为在大部分计算器体系结构中，int的底层表述不同于double的底层表述。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d;</span><br></pre></td></tr></table></figure>

<p>这里我们不过是建立一个base class指针指向一个derived class对象，但有时候上述的两个指针值并不相同。这种情况下会有个偏移量在运行期间被施行于Derived* 指针身上，用以取得正确的Base* 指针值。</p>
<p>上个例子表明，单一对象（例如一个类型为Derived的对象）可能拥有一个以上的地址（例如”以Base* 指向它“时的地址和“ 以Derived*指向它”时的地址。C不可能发生这种事，java不可能发生这种事，C#也不可能发生这种事。但是C++能！实际上一旦使用多重继承，这事几乎一直发生着。即使在单一继承中也可能发生。</p>
<p>请注意，说的是有时候需要一个偏移量。对象的布局方式和它们的地址计算方式随编译器的不同而不同，那意味着“由于知道对象如何布局”而设计的转型，在某一平台行得通，在其他平台并不一定行得通。</p>
<p>我们很容易写出似是而非的代码（在其他语言中也许真是对的）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWindow</span> :</span> <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;Window&gt;(*<span class="keyword">this</span>).<span class="built_in">onResize</span>();</span><br><span class="line">        ... <span class="comment">// 这里进行SpecialWindow专属行为</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段程序将*this转型为Window，对函数onResize的调用也因此调用了Window::onResize. 但恐怕你没有想到，它调用的并不是当前对象身上的函数，而是稍早转型动作所建立的一个” *this对象之base class成分”的暂时副本身上的onResize! 如果Window::onResize修改了对象内容，当前对象其实没有被改动，改动的是副本。</p>
<p>解决方法是，去掉转型动作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWindow</span> :</span> <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Window::<span class="built_in">onResize</span>();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>之所以需要dynamic_cast，通常是因为想在一个你认定为derived class对象身上执行derived class操作函数，但你的手上却只有一个“指向Base”的pointer或reference，你只能靠他们来处理对象。有两个一般性做法可以避免这个问题。</p>
<p>第一，使用容器并在其中存储直接指向derived class对象的指针（通常是智能指针），如此便消除了“通过base class接口处理对象”的需要。假设先前的Window/SpecialWindow继承体系中只有SpecialWindow才支持闪烁系统，试着不要这么做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWindow</span> :</span> <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">blink</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;Window&gt;&gt; VPW;</span><br><span class="line">VPW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (VPW::iterator iter = winPtrs.<span class="built_in">begin</span>(); iter != winPtrs.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">    <span class="keyword">if</span> (SpecialWindow* psw = <span class="keyword">dynamic_cast</span>&lt;SpecialWindow*&gt;(iter-&gt;<span class="built_in">get</span>())) &#123; <span class="comment">// 不希望使用dynamic_cast</span></span><br><span class="line">        psw-&gt;<span class="built_in">blink</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该这样做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;SpecialWindow&gt;&gt; VPSW;</span><br><span class="line">VPSW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (VPSW::iterator iter = winPtrs.<span class="built_in">begin</span>(); iter != winPtrs.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">    (*iter)-&gt;<span class="built_in">blink</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法无法在同一个容器内存储指针“指向所有可能之各种Window派生类”。如果真要处理多种窗口类型，可能需要多个容器。</p>
<p>另一种做法可让你通过base class接口处理“所有可能之各种Window派生类”，那就是在base class中提供virtual函数，做你想对各个Window派生类做的事。举个例子，虽然只有SpecialWindow可以闪烁，但或许将闪烁函数声明于base class内并提供“什么也不做”的默认实现代码是有意义的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">blink</span><span class="params">()</span> </span>&#123; &#125; <span class="comment">// 默认实现代码什么也没做</span></span><br><span class="line">    <span class="comment">// 条款34会说明默认实现代码可能是个馊主意</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWindow</span> :</span> <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">blink</span><span class="params">()</span> </span>&#123;...&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;Window&gt;&gt; VPW;</span><br><span class="line">VPW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (VPW::iterator iter = winPtrs.<span class="built_in">begin</span>(); iter != winPtrs.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">    (*iter)-&gt;<span class="built_in">blink</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>绝对必须避免的一件事是所谓的“连串dynamic_cast”，也就是看起来像这样的东西：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> &#123;</span>...&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;Window&gt;&gt; VPW;</span><br><span class="line">VPW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (VPW::iterator iter = winPtrs.<span class="built_in">beigin</span>(); iter != winPtrs.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">    <span class="keyword">if</span> (SpecialWidow *psw1 = <span class="keyword">dynamic_cast</span>&lt;SpecialWindow1&gt;(iter-&gt;<span class="built_in">get</span>())) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (SpecialWindow *psw2 = <span class="keyword">dynamic_cast</span>&lt;SpecialWindow2&gt;(iter-&gt;<span class="built_in">get</span>()) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的代码又大又慢，而且基础不稳，每次Window class继承体系一有改变，所有这一类代码都必须再次检阅看看是否需要修改。</p>
<blockquote>
<ul>
<li>如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_casts.如果有个设计需要转型动作，试着发展无需转型的替代设计</li>
<li>如果转型是有必要的，试着将他隐藏于某个函数背后。客户随后可以调用该函数，而不需将转型放进他们自己的代码中。</li>
<li>宁可使用C++ style转型，不要使用旧式转型。前者很容易辨识出来，而且也比较由着分门别类的职责。</li>
</ul>
</blockquote>
<h5 id="28-避免返回handles指向对象内部成分"><a href="#28-避免返回handles指向对象内部成分" class="headerlink" title="28. 避免返回handles指向对象内部成分"></a>28. 避免返回handles指向对象内部成分</h5><p>References、指针和迭代器统统都是所谓的handles（用来取得某个对象）</p>
<p>假设你的程序涉及矩形，每个矩形由其左上角和右下角表示。为了让一个Rectangle对象尽可能小，你可能会决定不把定义矩形的这些点存放在Rectangle对象内，而是放在一个辅助的struct内，再让Rectangle去指他：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y);</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetX</span><span class="params">(<span class="keyword">int</span> newVal)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetY</span><span class="params">(<span class="keyword">int</span> newVal)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RectData</span> &#123;</span></span><br><span class="line">    Point ulhc;</span><br><span class="line">    Point lrhc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::tr1::shared_ptr&lt;RectData&gt; pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rectangle的用户必须能够计算Rectangle的范围，所以这个class提供upperLeft函数和lowerRight函数。Point是用户自定义类型，所以返回reference：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">    <span class="function">Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样设计可以通过编译，但却是错误的。实际上他是自我矛盾的。一方面upperLeft和lowerRight被声明为const成员函数，因为它们的目的只是为了提供客户一个得知Rectangle相关坐标点的方法，而不是让客户修改Rectangle。另一方面两个函数都返回reference指向private内部函数，调用者于是可通过这些reference更改内部数据！例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">coord1</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">coord2</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Rectangle <span class="title">rec</span><span class="params">(coord1, coord2)</span></span>;</span><br><span class="line">rec.<span class="built_in">upperLeft</span>().<span class="built_in">setX</span>(<span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>调用者能够使用被返回的reference来更改成员。但是rec应该是不可变的</p>
<p>这给我们两个教训：第一，成员变量的封装性最多只等于”返回其reference“的函数的访问级别。本例中的ulhc和lrhc虽然都被声明为private，但是他们实际上却是public。第二，如果const成员函数传出一个reference，后者所指数据与对象自身有关联，而它又被存储于对象之外，那么这个函数调用者可以修改那笔数据。</p>
<p>通常我们认为，对象的”内容“就是指它的成员变量，但其实不被公开使用的成员函数（也就是被声明为protected或private者）也是对象”内容“的一部分。因此也应该留心不要返回他们的handles。</p>
<p>我们在这些函数身上遭遇的两个问题可以轻松去除，只要对它们的返回类型加上const即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但即使如此，upperLeft和lowerRight还是返回了”代表对象内部“的handles，有可能在其他场合带来问题。更明确的说，它可能导致dangling handles(空悬的handles)：这种handles所指东西（的所属对象）不复存在。这种”不复存在的对象“最常见的来源就是函数返回值。例如某个函数返回GUI对象的外框（bounding box),这个外框采用矩形形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GUIObject</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Rectangle</span></span><br><span class="line"><span class="function"><span class="title">boundingBox</span><span class="params">(<span class="keyword">const</span> GUIObject&amp; obj)</span></span>; <span class="comment">// 以value方式返回一个矩形</span></span><br></pre></td></tr></table></figure>

<p>现在，用户有可能这么使用这个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GUIObject* pgo;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> Point* pUpperLeft = &amp;(<span class="built_in">boundingBox</span>(*pgo).<span class="built_in">upperLeft</span>());</span><br></pre></td></tr></table></figure>

<p>对boundingBox()的调用获得一个新的、暂时的Rectangle对象。这个对象没有名称，所以我们权且称为temp。随后upperLeft作用于temp身上，返回一个引用指向temp的内部成分。随后temp将被销毁，间接导致temp内的Points析构。最终导致pUpperLeft指向一个不再存在的对象。</p>
<p>这并不意味着绝对不可以让成员函数返回handles，有时候必须那么做。例如operator[] 就允许你使用strings和vectors的个别元素，而这些operator[]s就是返回引用指向”容器内的数据“。那些数据会随着容器的销毁而销毁。尽管如此，这样的函数毕竟是例外，不是常态。</p>
<blockquote>
<ul>
<li>避免返回handles指向对象内部。遵守这个条款可以增加封装性，帮助const成员函数的行为像个const，并将发生dangling handles的可能性降至最低。</li>
</ul>
</blockquote>
<h5 id="29-为”异常安全“而努力是值得的"><a href="#29-为”异常安全“而努力是值得的" class="headerlink" title="29. 为”异常安全“而努力是值得的"></a>29. 为”异常安全“而努力是值得的</h5>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/05/Effective-C-%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95%E4%BA%94-26-31/" data-id="ckpkyp2830009hd3ahrmr0f96" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Effective-C/" rel="tag">Effective C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Effective-C-改善程序与设计的55个具体做法-四-18-25" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/17/Effective-C-%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95-%E5%9B%9B-18-25/" class="article-date">
  <time datetime="2019-12-17T12:42:37.000Z" itemprop="datePublished">2019-12-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/17/Effective-C-%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95-%E5%9B%9B-18-25/">Effective-C-改善程序与设计的55个具体做法(四)(18~25)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="四-设计与声明"><a href="#四-设计与声明" class="headerlink" title="四. 设计与声明"></a>四. 设计与声明</h4><h5 id="18-让接口容易被正确使用，不易被误用"><a href="#18-让接口容易被正确使用，不易被误用" class="headerlink" title="18. 让接口容易被正确使用，不易被误用"></a>18. 让接口容易被正确使用，不易被误用</h5><p>C++ function接口，class接口，template接口…,每一种接口都是客户与你的代码互动的手段。理想上，如果客户企图使用某个接口而却没有获得他所预期的行为，这个代码不该通过编译；如果代码通过了编译，它的作为就该是客户所想要的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="keyword">int</span> month, <span class="keyword">int</span> day, <span class="keyword">int</span> year);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用户在使用上述接口时，很容易犯下至少两个错误：第一，错误的次序传递参数。第二，传递无效的月份或参数。</p>
<p>上述易产生的错误可以通过导入新类型来预防。分别导入外覆类型来区别天数，月份和年份</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Day</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Day</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    : val(d) &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="keyword">const</span> Month&amp; m, <span class="keyword">const</span> Day&amp; d, <span class="keyword">const</span> Year&amp; y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>限制自定义类型的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Month</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Month <span class="title">Jan</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Month <span class="title">Feb</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">2</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="keyword">int</span> m)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month::mar(), Day(<span class="number">30</span>), Year(<span class="number">1995</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p>为了提供行为一致的接口，避免无端与内置类型不兼容”除非有好理由，否则应该尽量令你的types的行为与内置types一致”。</p>
<p>任何接口如果要求客户必须记得做某些事情，就是有着”不正确使用“的倾向。</p>
<blockquote>
<ul>
<li>好的接口很容易被正确使用，不容易被误用。应该在所有的接口中努力达成这些性质</li>
<li>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容</li>
<li>“阻止误用”的办法包括建立新类型，限制类型上的操作，束缚对象值，以及消除客户的资源管理责任</li>
<li>tr1::shared_ptr支持定制型删除器。这可防范DLL问题，可被用来自动解除互斥锁等等。</li>
</ul>
</blockquote>
<h5 id="19-设计class犹如设计type"><a href="#19-设计class犹如设计type" class="headerlink" title="19. 设计class犹如设计type"></a>19. 设计class犹如设计type</h5><p>设计优秀的classes是一项艰巨的工作，几乎每一个class都要求你面对以下提问：</p>
<ul>
<li>新type的对象应该如何被创建和销毁？</li>
</ul>
<p>这会影响到你的class的构造函数和析构函数以及内存分配函数和释放函数的设计</p>
<ul>
<li>对象的初始化和对象的赋值该有什么样的差别？</li>
</ul>
<p>这个答案决定你的构造函数和赋值操作符的行为，以及其间的差异。很重要的是别混淆了“初始化”和“赋值”，因为他们对应于不同的函数调用。</p>
<ul>
<li>新type的对象如果被passed by value，意味着什么？</li>
</ul>
<p>记住，copy构造函数用来定义一个type的pass-by-value该如何实现</p>
<ul>
<li>什么是新type的“合法值”？</li>
</ul>
<p>对class的成员变量而言，通常只有某些数值集是有效的。那些数值集决定了你的class必须维护的约束条件，也就决定了你的成员函数必须进行的错误检查工作。</p>
<ul>
<li>你的新type需要配合某个继承图系吗？</li>
</ul>
<p>如果你继承自某些既有的classes，你就受到哪些classes的设计的束缚，特别是受到“它们的函数是virtual或non-virtual”的影响。如果你允许其他calsses继承你的class，那会影响你所声明的函数-尤其是析狗函数–是否为virtual。</p>
<ul>
<li>你的新type需要什么样的转换？</li>
</ul>
<p>你的type生存与其他很多types之间，因而彼此该有转换行为吗？如果你希望允许类型T1之物被隐士转换为类型T2之物，就必须在class T1内写一个类型转换函数（operator T2）或在class T2内写一个non-explicit-one-argument（可被单一实参调用）的构造函数。如果你只允许explicit构造函数存在，就得专门写出负责执行转换的函数，且不得为类型转换操作符或non-explicit-one-argument构造函数（条款15有隐式和显式转换函数的范例）</p>
<ul>
<li>什么样的操作符和函数对此新type而言是合理的？</li>
</ul>
<p>这个问题的答案决定将为你的class声明哪些函数。其中某些该是member函数，某些则否</p>
<ul>
<li>什么样的标准函数应该驳回？</li>
</ul>
<p>那些正是你必须声明为private者</p>
<ul>
<li>谁该取用新type的成员？</li>
</ul>
<p>这个提问可以帮你决定哪个成员为public，哪个为protected，哪个为private。它也帮助你决定哪一个classes或functions应该是friends，以及将他们嵌套于另一个之内是否合理。</p>
<ul>
<li>什么是新type的”未声明“接口？</li>
</ul>
<p>它对效率、异常安全性（见条款29）以及资源运用（例如多任务锁定和动态内存）提供何种保证？你在这些方面提供的保证将为你的class实现代码加上相应的约束条件。</p>
<ul>
<li>你的新type有多么一般化？</li>
</ul>
<p>或许你其实并非定义一个新type，而是定义一整个types家族，果真如此你就不该定义一个新class，而是应该定义一个新的class template。</p>
<ul>
<li>你真的需要一个新type吗？</li>
</ul>
<p>如果只是定义新的derived class以便为既有的class添加机能，那么说不定单纯定义一或多个non-member函数或templates，能够达到目标。</p>
<blockquote>
<ul>
<li>Class的设计就是type的设计。在定义一个新的type之前，请确定你已经考虑过本条款的所有讨论主题。</li>
</ul>
</blockquote>
<h5 id="20-宁以pass-by-reference-to-const-替换pass-by-value"><a href="#20-宁以pass-by-reference-to-const-替换pass-by-value" class="headerlink" title="20. 宁以pass-by-reference-to-const 替换pass-by-value"></a>20. 宁以pass-by-reference-to-const 替换pass-by-value</h5><p>默认情况下C++以pass by value的方式传递对象至函数。除非另外指定，否则函数参数都是以实参的复件为初值，而调用端所获得的也是函数返回值的一个复件。这些复件由对象的copy构造函数产出，这可能使pass-by-value成为耗时的操作。考虑以下class继承体系：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::string address;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>();</span><br><span class="line">    ~<span class="built_in">Student</span>();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string schoolName;</span><br><span class="line">    std::string schoolAddress;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validateStudent</span><span class="params">(Student s)</span></span>; <span class="comment">// pass by value</span></span><br><span class="line">Student plato;</span><br><span class="line"><span class="keyword">bool</span> platoIsOK = <span class="built_in">validateStudent</span>(palto);</span><br></pre></td></tr></table></figure>

<p>上述调用过程中参数的传递成本是”一次Student copy构造函数调用，再加上一次Student析构函数调用。再加上类内部的string，总体成本是六次构造函数和六次析构函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validateStudent</span><span class="params">(<span class="keyword">const</span> Student&amp; s)</span></span>; <span class="comment">// 这种传递方式的效率要高得多</span></span><br></pre></td></tr></table></figure>

<p>这种传递方式效率要高得多，没有任何构造函数或析构函数被调用，因为没有任何新对象被创建。</p>
<p>以引用方式传递参数也可以避免slicing（对象切割）问题。<strong>当一个derived class对象以by value方式传递并被视为一个base class对象，base class的copy构造函数会被调用</strong>，而造成此对象的行为像个derived class对象的那些特性化性质全被切割掉了，仅仅留下一个base class对象。</p>
<p>对内置类型而言，选择pass-by-value往往比引用传递效率高些，对于STL的迭代器和函数对象同样适用。但是迭代器和函数对象适用pass-by-value时需要确认它们不受切割问题的影响。</p>
<p>内置类型都相当小，但并不是所有小型types都适合pass-by-value。对象小并不意味其copy构造函数不昂贵。许多对象–包括大多数STL容器–内含的东西只比指针多一些，但是复制这种对象确需要承担“复制那些指针所指的每一样东西”。那将非常昂贵。</p>
<p>即使小型对象拥有并不昂贵的copy构造函数，还是可能有效率上的争议。某些编译器对待“内置类型”和“用户自定义类型”的态度截然不同，纵使两者拥有相同的底层表述。例如：某些编译器拒绝把只由一个double组成的对象放进缓存器内，却很乐意在一个正规基础上对光秃秃的doubles那么做。当这种事情发生时，就应该以引用方式传递此对象。</p>
<p>“小型用户自定义类型不是必然成为pass-by-value”的另一个理由是：作为一个用户自定义类型，其大小容易有所变化。一个type目前虽然小，将来也许会变大。甚至改用另一个C++编译器都可能改变type的大小。</p>
<p>一般而言，可以假设“值传递”的唯一对象就是内置类型和STL的迭代器和函数对象。</p>
<blockquote>
<ul>
<li>尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并且可以避免切割问题。</li>
<li>以上规则并不适用于内置类型，以及STL的迭代器和函数对象。对他们而言，值传递往往比较适当。</li>
</ul>
</blockquote>
<h5 id="21-必须返回对象时，别妄想返回其reference"><a href="#21-必须返回对象时，别妄想返回其reference" class="headerlink" title="21. 必须返回对象时，别妄想返回其reference"></a>21. 必须返回对象时，别妄想返回其reference</h5><p>一心一意根除值传递带来的种种坏处，坚定追求引用传递时，容易犯下一个致命错误：开始传递一些指向其实并不存在的对象。</p>
<p>考虑一个用以表现有理数的class，内含一个函数用来计算两个有理数的乘积：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="keyword">int</span> numerator = <span class="number">0</span>, <span class="keyword">int</span> denominator = <span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n, d; <span class="comment">// 分子和分母</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs); <span class="comment">// 友元函数不是类的成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个版本的operator<em>使用by value的方式返回其计算结果。如果改用引用传递，就不需要copy构造和析构的成本。但是记住，<strong>所谓引用只是个名称，代表某个既有对象。任何时候看到一个引用声明式，都应该立刻问自己，它的另外一个名称是什么？因为它一定是某物的另一个名称。</strong>以上述operator</em>为例，如果它返回一个reference，后者一定指向某个既有的Rational对象，内含两个Rational对象的乘积。</p>
<p>我们当然不可能期望这样一个Rational对象在调用operator*之前就存在。也就是说，如果你有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; <span class="comment">// a = 1/2</span></span><br><span class="line"><span class="function">Rational <span class="title">b</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>; <span class="comment">// b = 3/5</span></span><br><span class="line">Ratioanl c = a * b; <span class="comment">// c应该是3/10</span></span><br></pre></td></tr></table></figure>

<p>期望原本就存在一个值为3/10的Rational对象并不合理。</p>
<p>函数创建新对象的途径有两个：在stack空间和heap空间。如果定义一个local变量，就是在stack空间创建对象。根据这个策略试写operator*如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational&amp; <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">    <span class="function">Rational <span class="title">result</span><span class="params">(lhs.n * rhs.n, lhs.d * rhs.d)</span></span>; <span class="comment">// 糟糕的代码！</span></span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 返回一个local对象，而local对象在函数退出前就销毁了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>避免上述的写法，因为目标是要避免调用构造函数，而result却必须由构造函数构造起来。更严重的是：这个函数返回的result引用，在函数退出前就已经被销毁了。</p>
<p>于是，考虑在heap内创建一个对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational&amp; <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">    Rational *result = <span class="keyword">new</span> <span class="built_in">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.d);</span><br><span class="line">    <span class="keyword">return</span> *result; <span class="comment">// 更糟糕的写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是必须付出一个构造函数调用的代价，同时又有另一个问题：该谁对着被new出来的对象实施delete？</p>
<p>即使调用者谨慎，出于良好的意识，他们还是不能够在这样合情合理的用法下阻止内存泄露：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rational w, x, y, z;</span><br><span class="line">w = x * y * z;</span><br></pre></td></tr></table></figure>
<p>这里同一个语句内调用了两次operator<em>，因而两次使用new， 也就需要两次delete。但是确没有合理的办法进行资源释放。因为没有合理的办法让他们取得operator</em> 返回的引用背后隐藏的那个指针。会造成内存泄露。</p>
<p>上述两种方法都产生了构造函数调用，有一种办法可以避免任何的构造函数调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational&amp; <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">static</span> Rational result; <span class="comment">// 又一堆烂代码</span></span><br><span class="line">    result = ...;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像所有用上static对象的设计一样，这一个也立刻造成我们对多线程安全性的疑虑。更深层的瑕疵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>== (<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs);</span><br><span class="line"></span><br><span class="line">Rational a, b, c, d;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> ((a * b) == (c * d)) &#123;</span><br><span class="line">    <span class="comment">// 乘积相等时，做相应的动作</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 乘积不等时，做相应的动作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if判断的结果总是为true，不论a、b、c的值是什么。代码的等价形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">operator</span>==(<span class="keyword">operator</span>*(a, b), <span class="keyword">operator</span>*(c, d)))</span><br></pre></td></tr></table></figure>

<p>在operator==调用之前，已有两个operator<em>调用式起作用，每一个都返回reference指向operator</em>内部定义的static Rational对象。因此一直返回true。<strong>（两次operator*调用的确各自改变了static Rational对象值，但由于他们返回的都是引用，因此调用端看到的永远是static Rational对象的“现值”）</strong>。</p>
<p>综上所述：一个“必须返回新对象”的函数的正确写法是，就让那个函数返回一个新对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然需要承担operator*返回值的构造成本和析构成本，但是长远来看是为了获得正确行为而付出的一个小小代价。</p>
<blockquote>
<ul>
<li>绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或referenc指向一个local static对象而有可能同时需要多个这样的对象。</li>
</ul>
</blockquote>
<h5 id="22-将成员变量声明为private"><a href="#22-将成员变量声明为private" class="headerlink" title="22.将成员变量声明为private"></a>22.将成员变量声明为private</h5><p>首先从语法一致性说起（条款18）。如果成员变量不是public，客户唯一能够访问对象的办法就是通过成员函数。如果public接口内的每样东西都是函数，客户就不需要在打算访问class成员时试着记住是否该使用小括号。</p>
<p>使用函数可以让你对成员变量的处理有更精确的控制。使用函数可以实现出“不准访问”，“只读访问”以及“读写访问”。如果通过函数访问成员变量，日后可改以某个计算替换这个成员变量，而class客户一点也不会知道class的内部实现已经起了变化。</p>
<p>将成员变量隐藏在函数接口的背后，可以为“所有可能的实现”提供弹性。</p>
<blockquote>
<ul>
<li>切记将成员变量声明为private。这可以赋予客户访问数据的一致性，可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性。</li>
<li>protected并不比public更具封装性。从封装的角度来说，其实只有两种访问权限：private（提供封装）和其他（不提供封装）</li>
</ul>
</blockquote>
<h5 id="23-宁以non-member、non-friend替换成员函数"><a href="#23-宁以non-member、non-friend替换成员函数" class="headerlink" title="23. 宁以non-member、non-friend替换成员函数"></a>23. 宁以non-member、non-friend替换成员函数</h5><p>加入有个class用来表示网页浏览器。这样的class可能提供的众多的函数中，有一些用来清除下载元素告诉缓存区、清除访问过的URLs的历史记录、以及移除系统中的所有cookies。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeCookies</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>许多用户会想一整个执行所有这些动作，因此WebBrowser也提供这样一个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearEveryThing</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然，这一机能也可由一个non-member函数调用适当的member函数而提供出来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span> </span>&#123;</span><br><span class="line">    wb.<span class="built_in">clearCache</span>();</span><br><span class="line">    wb.<span class="built_in">clearHistory</span>();</span><br><span class="line">    wb.<span class="built_in">removeCookies</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哪一个比较好呢？是clearEveryThing还是clearBrowser?</p>
<p>面向对象守则要求,数据以及操作数据的那些函数应该被捆绑在一块，这意味着他建议member函数是较好的选择。不幸的是这个建议不正确。这事基于面向对象真实意义的一个误解。面向对象守则要求数据应该尽可能被封装，然而与直观相反地，member函数clearEveryThing带来的封装性比non-member函数clearBrowser低。此外，提供non-member函数可允许对WebBrowser相关机能有较大的包裹弹性，而那最终导致较低的编译相依度，增加WebBrowser的可延伸性。因此在许多方面non-member做法比member做法好。</p>
<p>只因在意封装性而让函数称为class的non-member并不意味着它“不可以是另一个class的member”。例如我们可以令clearBrowser成为某个工具类的一个static member函数。只要它不是WebBrowser的一部分（或friend），就不会影响WebBrowser的private成员封装性。</p>
<p>一个像WebBrowser这样的class可能拥有大量便利函数，某些与书签有关，某些与打印有关，还有一些与cookie的管理有关…，通常客户只对其中的某些感兴趣。分离他们的最直接做法就是将书签相关便利函数声明于一个头文件，将cookie相关便利函数声明于另外一个头文件。。。这样允许客户只对他们所用的那一小部分系统形成编译相依。</p>
<blockquote>
<ul>
<li>宁可拿non-member non-friend函数替换member函数。这样做可以增加封装性、包裹弹性和机能扩充性。</li>
</ul>
</blockquote>
<h5 id="24-若所有参数皆需类型转换，请为此采用non-member函数"><a href="#24-若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="24. 若所有参数皆需类型转换，请为此采用non-member函数"></a>24. 若所有参数皆需类型转换，请为此采用non-member函数</h5><p>令class支持隐式类型转换通常是个糟糕的主意。当然这条规则有其例外，最常见的例外是在建立数值类型时。假设设计一个class用来表现有理数，允许整数隐式转换为有理数颇为合理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="keyword">int</span> numberator = <span class="number">0</span>, <span class="keyword">int</span> denominator = <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">denominator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>你想支持算术运算诸如加法、乘法等等，但是是采用member函数? non-member函数？或可能的话由non-member friend函数？</p>
<p>首先member函数的写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种写法使你能够将两个有理数相乘：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneEight</span><span class="params">(<span class="number">1</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational result = oneEight * oneHalf; <span class="comment">// OK</span></span><br><span class="line">result = result * oneEight; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>然而当进行混合式运算，会发现只有一半行得通：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = oneHalf * <span class="number">2</span>; <span class="comment">// OK</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf; <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure>

<p>以函数形式重写上述两个式子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = oneHalf.<span class="keyword">operator</span>*(<span class="number">2</span>); <span class="comment">// OK</span></span><br><span class="line">result = <span class="number">2.</span><span class="keyword">operator</span>*(oneHalf); <span class="comment">// ERROR!</span></span><br></pre></td></tr></table></figure>

<p>oneHalf是一个内含operator* 函数的class的对象，所以编译器调用该函数，然而整数2并没有相应的class，也就没有operator* 成员函数。</p>
<p>注意上述调用成功的那个2，发生了隐式类型转换，编译器知道正在传递一个int，而函数需要的是Rational；但他知道只要调用Rational构造函数并赋予所提供的int，就可以变出一个适当的Rational来。如果构造函数指定explicit，则上述两个都将编译失败。</p>
<p>只有当参数被列于参数列内，这个参数才是隐式类型转换的合格参与者。</p>
<p>想要支持混合式算术运算，可行的方法是：让operator* 成为一个non-member函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; rhs, <span class="keyword">const</span> Rational&amp; lhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numberator</span>() * rhs.<span class="built_in">numberator</span>(), lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Rational <span class="title">oneFourth</span><span class="params">(<span class="number">1</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">Rational result;</span><br><span class="line">result = oneFourth * <span class="number">2</span>; <span class="comment">// OK</span></span><br><span class="line">result = <span class="number">2</span> * oneFourth; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>不适用friend的原因是：无论何时如果可以避免friend函数就该避免。</p>
<blockquote>
<ul>
<li>如果你需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个non-member。</li>
</ul>
</blockquote>
<h5 id="25-考虑写出一个不抛异常的swap函数"><a href="#25-考虑写出一个不抛异常的swap函数" class="headerlink" title="25. 考虑写出一个不抛异常的swap函数"></a>25. 考虑写出一个不抛异常的swap函数</h5><p>所谓swap两对象值，意思是将两对象的值彼此赋予对方。默认情况下swap动作可由标准程序库提供的swap算法完成。其典型的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123; <span class="comment">// 类型T支持copy(copy 构造函数和 copy assignment)</span></span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个默认的swap实现版本十分平淡，涉及到了三个对象的复制。但是对某些类型而言，这些复制动作无一必要。</p>
<p>其中最主要的就是“以指针指向一个对象，内含真正数据”那种类型。这种设计的常见表现形式是所谓“pimpl手法”。如果以这种手法设计Widget class，看起来就会像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a, b, c; <span class="comment">// 可能有许多数据，意味着复制时间很长</span></span><br><span class="line">    std::vector&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> <span class="comment">// 这个class使用pimpl手法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="keyword">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">        ...</span><br><span class="line">        *pImpl = *(rhs.pImpl); <span class="comment">// operator=的一般性实现细节，参照条款10，11，12</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl* pImpl; <span class="comment">// 指针，所指对象内含Widget数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一旦要置换两个Widget对象值，我们唯一需要做的就是置换其pImpl指针，但是默认的swap算法并不知道这一点。</p>
<p>我们希望能够告诉std::swap；当Widgets被置换时真正该做的是置换其内部的pImpl指针。下面是基本构想：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">void</span> swap&lt;Widget&gt; (Widget&amp; a, Widget&amp; b) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a.pImpl, b.pImpl); <span class="comment">// 目前还不能编译过</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数一开始的“template&lt;&gt;”表示它是std::swap的一个全特化版本，函数名称之后的”&lt;Widget&gt;”表示这一特化版本是针对“T是Widget”而设计。通常我们不能改变std命名空间内的任何东西，但可以为标准templates（如swap）制造特化版本，使它专属于我们自己的classes。以上作为正是如此。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> <span class="comment">// 与前相同，唯一区别是增加swap函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap; <span class="comment">// 这个声明之所以必要，稍后解释</span></span><br><span class="line">        <span class="built_in">swap</span>(pImpl, other.pImpl); <span class="comment">// 若要置换Widgets就置换其pImpl指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">void</span> swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b) &#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b); <span class="comment">// 若要置换Widgets,调用其swap成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法不仅能够通过编译，还与STL容器有一致性，因为所有STL容器也都提供有public swap成员函数和std::swap特化版本（用以调用前者）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WidgetImpl</span>()</span><br><span class="line">    : <span class="built_in">a</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">b</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">c</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">WidgetImpl</span>(<span class="keyword">int</span> _a, <span class="keyword">int</span> _b, <span class="keyword">int</span> _c)</span><br><span class="line">    : <span class="built_in">a</span>(_a)</span><br><span class="line">    , <span class="built_in">b</span>(_b)</span><br><span class="line">    , <span class="built_in">c</span>(_c)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">WidgetImpl</span>(WidgetImpl&amp; rhs) &#123;</span><br><span class="line">        a = rhs.a;</span><br><span class="line">        b = rhs.b;</span><br><span class="line">        c = rhs.c;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (std::vector&lt;<span class="keyword">double</span>&gt;::iterator iter = rhs.v.<span class="built_in">begin</span>(); iter != rhs.v.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(*iter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addVec</span><span class="params">(<span class="keyword">double</span> w)</span> </span>&#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (std::vector&lt;<span class="keyword">double</span>&gt;::iterator iter = v.<span class="built_in">begin</span>(); iter != v.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">            cout &lt;&lt; *iter &lt;&lt; endl; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WidgetImpl&amp; <span class="keyword">operator</span>=(WidgetImpl&amp; rhs) &#123;</span><br><span class="line">        a = rhs.a;</span><br><span class="line">        b = rhs.b;</span><br><span class="line">        c = rhs.c;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (std::vector&lt;<span class="keyword">double</span>&gt;::iterator iter = rhs.v.<span class="built_in">begin</span>(); iter != rhs.v.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(*iter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">WidgetImpl</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    std::vector&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(WidgetImpl* rhs)</span><br><span class="line">    : <span class="built_in">pImpl</span>(rhs)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Widget</span>(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">        pImpl = rhs.pImpl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(pImpl, other.pImpl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pImpl-&gt;<span class="built_in">printImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">        WidgetImpl* pOrig = pImpl;</span><br><span class="line">        pImpl = <span class="keyword">new</span> <span class="built_in">WidgetImpl</span>(*rhs.pImpl);</span><br><span class="line">        <span class="keyword">delete</span> pOrig;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl* pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">void</span> swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b) &#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">WidgetImpl <span class="title">tmp</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    tmp.<span class="built_in">addVec</span>(<span class="number">2.1</span>);</span><br><span class="line">    tmp.<span class="built_in">printImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">WidgetImpl <span class="title">tmp1</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    tmp1.<span class="built_in">addVec</span>(<span class="number">2.2</span>);</span><br><span class="line">    tmp1.<span class="built_in">printImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">Widget <span class="title">tmp2</span><span class="params">(&amp;tmp)</span></span>;</span><br><span class="line">    tmp2.<span class="built_in">printWidget</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">Widget <span class="title">tmp3</span><span class="params">(&amp;tmp1)</span></span>;</span><br><span class="line">    tmp3.<span class="built_in">printWidget</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(tmp2, tmp3);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After swap&quot;</span> &lt;&lt; endl;</span><br><span class="line">    tmp2.<span class="built_in">printWidget</span>();</span><br><span class="line">    tmp3.<span class="built_in">printWidget</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而假设Widget和WidgetImpl都是class template而非classes，也许可以试试将WidgetImpl内的数据类型加以参数化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span> &#123;</span>...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span>...&#125;;</span><br></pre></td></tr></table></figure>

<p>在Widget内放个swap成员函数跟以往一样。但是我们却在特化std::swap时遇上乱流：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">void</span> swap&lt; Widget&lt;T&gt; &gt;(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b) &#123; <span class="comment">// 错误，不合法！</span></span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们企图偏特化（partially specialize)一个function template（std::swap)，但C++只允许对class templates偏特化，在function template身上偏特化是行不通的。</p>
<p>当打算偏特化一个function template时，惯常做法是简单地为它添加一个重载版本，像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123; <span class="comment">// std::swap的重载版本，也不合法</span></span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般而言，重载function templates没有问题，但std是个特殊的命名空间，其管理规则也比较特殊。客户可以全特化std内的template，但是不可以添加新的templates（或classes或functions）到std里头。std的内容完全由C++标准委员会决定。</p>
<p>我们还是声明一个non-member swap让它调用member swap，但不再将那个non-member swap声明为std::swap的特化版本或重载版本。为求简化起见，假设Widget的所有相关机能都被置于命名空间WidgetStuff内，整个结果看起来便像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span>...&#125;; <span class="comment">// 同前，内含swap成员函数</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123; <span class="comment">// WidgetStuff命名空间</span></span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个做法对classes和class templates都行得通，所以似乎我们应该在任何时候都使用它。但是有一个理由使你应该为class特化std::swap，所以如果你想要你的”class 专属版“swap在尽可能多的语境下被调用，需要在该class所在命名空间内写一个non-member版本以及一个std::swap特化版本。</p>
<p>目前为止所写的每一样东西都和swap编写者有关。换位思考，从用户观点来看事情也有必要。假设你正在写一个function template，其内需要置换两个对象值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1, T&amp; obj2)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">swap</span>(obj1, obj2);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该调用哪个swap？下面是你希望发生的事：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1, T&amp; obj2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap; <span class="comment">// 令std::swap在此函数调用</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">swap</span>(obj1, obj2); <span class="comment">// 为T型对象调用最佳swap版本</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦编译器看到对swap函数的调用，它们便查找适当的swap并调用之。C++的名称查找法则确保找到global作用域或T所在之命名空间内的任何T专属的swap。如果T是Widget并位于命名空间WidgetStuff内，编译器会使用”实参取决之查找规则“，没有T专属之swap存在，编译器就使用std内的swap，这得感谢using声明式让std::swap在函数内曝光。然而即便如此编译器还是比较喜欢std::swap的T专属特化版，而非一般化的那个template。</p>
<p>因此，令适当的swap被调用是很容易的。需要小心的是，别为这一调用添加额外修饰符，因为那会影响C++挑选适当函数，假设你以如下方式调用swap：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">swap</span>(obj1, obj2); <span class="comment">// 这是错误的swap调用方式</span></span><br></pre></td></tr></table></figure>

<p>总结：如果swap默认实现版的效率不足，试着做以下事情：</p>
<ol>
<li>提供一个public swap成员函数，让它高效地置换你的类型的两个对象值。</li>
<li>在你的class后template所在的命名空间内提供一个non-member swap，并令他调用上述swap成员函数。</li>
<li>如果你正编写一个class（而非class template），为你的class特化std::swap。并令它调用你的swap成员函数。</li>
</ol>
<blockquote>
<ul>
<li>当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常。</li>
<li>如果你提供一个member swap，也该提供一个non-member swap用来调用前者。对于classes（而非templates),也请特化std::swap。</li>
<li>调用swap时应针对std::swap使用using声明式，然后调用swap并且不带任何”命名空间资格修饰“。</li>
<li>为”用户定义类型“进行std template全特化是好的，但千万不要尝试在std内加入某些对std而言全新的东西。</li>
</ul>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/17/Effective-C-%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95-%E5%9B%9B-18-25/" data-id="ckpkyp28q000zhd3a4is3adjh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Effective-C/" rel="tag">Effective C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Effective-C-改善程序与设计的55个具体做法-三-13-17" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/17/Effective-C-%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95-%E4%B8%89-13-17/" class="article-date">
  <time datetime="2019-12-17T12:42:11.000Z" itemprop="datePublished">2019-12-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/17/Effective-C-%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95-%E4%B8%89-13-17/">Effective-C-改善程序与设计的55个具体做法(13~17)(三)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="三、资源管理"><a href="#三、资源管理" class="headerlink" title="三、资源管理"></a>三、资源管理</h4><p>所谓资源就是，一旦用了它，将来必须还给系统。C++中最常使用的资源就是动态分配内存，其他常见的资源还包括文件描述器(file descriptors)，互斥锁，图形界面中的字型和笔刷，数据库连接，以及网络sockets,不论哪一种资源，当不再使用它时，必须将它归还给系统。</p>
<h5 id="13-以对象管理资源"><a href="#13-以对象管理资源" class="headerlink" title="13. 以对象管理资源"></a>13. 以对象管理资源</h5><p>假设我们使用一个用来模拟投资行为（例如股票，债券等等）的程序库，其中各式各样的投资类型继承自一个root clas Investment;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Investment</span> &#123;</span> ... &#125;; <span class="comment">// &quot;投资类型&quot;继承体系中的root class</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过工厂函数供应我们某特定的Investment对象</span></span><br><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Investment* pInv = <span class="built_in">createInvestment</span>(); <span class="comment">// 调用factory函数</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">delete</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“…”区域可能会含有return语句，这样就不会执行delete动作。</p>
<p>为确保createInvestment返回的资源总是被释放，我们需要将资源放进对象内，当控制流离开f，该队象的析构函数会自动释放那些资源。</p>
<p>许多资源被动态分配于heap内而后被用于单一区块或函数内。它们应该在控制流离开那个区块或函数时被释放。标准程序库提供的auto-ptr正是针对这种形势而设计的特制的产品。auto-ptr是个类指针对象，也就是所谓的智能指针。下面是如何使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::auto_ptr&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line">    ... <span class="comment">// 就像以前使用pInv，不必delete，经由auto_ptr的析构函数自动删除pInv</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述简单的例子示范”以对象管理资源“两个关键想法:</p>
<ul>
<li>获得资源后立刻放进管理对象内</li>
<li>管理对象利用析构函数确保资源被释放</li>
</ul>
<p>为了防止多个auto_ptr同时指向同一对象，auto_ptr有一个不寻常的性质：<strong>若通过copy构造函数或copy assignment操作符复制他们，它们会变成null，而复制所得的指针将取得资源的唯一使用权。</strong></p>
<p>这一诡异的复制行为，意味着auto_ptr并非管理动态资源的好方法，例如：STL容器要求其元素发挥”正常的“复制行为，因此这些容器容不得auto_ptr。</p>
<p>auto_ptr的替代方案是”引用计数型智能指针“，它可以持续追踪共有多少对象指向某笔资源，并且在无人指向它时自动删除该资源。引用计数型智能指针无法打破环状引用（两个其实已经没被使用的对象彼此互指，因而好像还处在”被使用“状态）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pInv1</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line">    std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pInv2</span><span class="params">(pInv1)</span></span>;</span><br><span class="line">    pInv1 = pInv2;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>auto_ptr和tr1::shared_ptr两者都在其析构函数内做delete而不是delete[]动作。意味着不能用在动态分配而得的array身上。</p>
<h5 id="14-在资源管理中小心copy行为"><a href="#14-在资源管理中小心copy行为" class="headerlink" title="14. 在资源管理中小心copy行为"></a>14. 在资源管理中小心copy行为</h5><p>自己建立资源管理类，假设我们使用C API函数处理类型为Mutex的互斥器对象共有lock和unlock两个函数可以使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(Mutex* pm)</span></span>; <span class="comment">// 锁定pm所指的互斥器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(Mutex* pm)</span> <span class="comment">// 将互斥器解除锁定</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class Lock </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* pm)</span></span></span><br><span class="line"><span class="function">    : mutexPtr(pm)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="built_in">lock</span>(mutexPtr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Lock</span>() &#123;</span><br><span class="line">        <span class="built_in">unlock</span>(mutexPtr);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex* mutexPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Mutex m; <span class="comment">// 定义所需的互斥器</span></span><br><span class="line">...</span><br><span class="line">&#123; <span class="comment">// 建立一个区块用来定义critical section</span></span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;m)</span></span>; <span class="comment">// 锁定互斥器</span></span><br><span class="line">    ... <span class="comment">// 执行critial section内的操作</span></span><br><span class="line">&#125; <span class="comment">// 在区块最末尾，自动解除互斥器锁定</span></span><br></pre></td></tr></table></figure>

<p>如果某个Lock对象被复制，会发生什么？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Lock <span class="title">m11</span><span class="params">(&amp;m)</span></span>; <span class="comment">// 锁定m</span></span><br><span class="line"><span class="function">Lock <span class="title">m12</span><span class="params">(m11)</span></span>; <span class="comment">// 将m11复制到m12</span></span><br></pre></td></tr></table></figure>

<p>大多数情况会选择以下两种可能：</p>
<ul>
<li>禁止复制</li>
</ul>
<p>许多时候允许RAII对象被复制不合理。如果复制动作对RAII class不合理，便应该禁止复制，见条款6</p>
<ul>
<li>对底层资源祭出”引用计数法“</li>
</ul>
<p>有时候我们希望保有资源，直到它的最后一个使用者（某对象）被销毁。这种情况下复制RAII 对象时，应该将资源的”被引用数“递增。tr1::shared_ptr便是如此.</p>
<p>通常只要内含一个tr1::shared_ptr成员变量，RAII classes便可实现reference-counting copying行为。如果前述的Lock打算使用引用计数，它可以改变mutexPtr的类型，将它从Mutex*改为tr1::shared_ptr&lt;Mutex&gt;。然而很不幸tr1::shared_ptr的缺省行为是“当引用次数为0时删除其所指物”，那不是我们所要的行为。当我们用上一个Mutex，我们想要做的释放动作是解除锁定而非删除。</p>
<p>幸运的是tr1::shared_ptr允许指定所谓的“删除器”，那是一个函数或函数对象，当引用次数为0时便被调用（此机能并不存在于auto_ptr-他总是将其指针删除）。删除器对tr1::shared_ptr构造函数而言是可有可无的第二参数，所以代码看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* pm)</span> <span class="comment">// 以某个Mutex初始化shared_ptr</span></span></span><br><span class="line"><span class="function">    : mutexPtr(pm, unlock) // 并以unlock函数为删除器</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="built_in">lock</span>(mutexPtr.<span class="built_in">get</span>()); <span class="comment">// 条款15谈到“get&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::tr1::shared_ptr&lt;Mutex&gt; mutexPtr; <span class="comment">// 使用shared_ptr替换raw pointer</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>本例的Lock class不再声明析构函数。因为没有必要。条款5说过class析构函数（无论是编译器生成的，或用户自定的）会自动调用其non-static成员变量（本例为mutexPtr)的析构函数。而mutexPtr的析构函数会在互斥器的引用次数为0时自动调用删除器（unlock）。</p>
<ul>
<li>复制底部资源</li>
</ul>
<p>对一份资源可以拥有任意数量的复件。而需要”资源管理类”的唯一理由是，当你不再需要某个复件时确保它被释放。在此情况下复制资源管理对象，应该同时也复制其所包裹的资源（深度拷贝）。</p>
<ul>
<li>转移底部资源的拥有权</li>
</ul>
<p>极少数的情况下可能希望确保永远只有一个RAII对象指向一个未加工资源（raw resource），即使RAII对象被复制依然如此。此时资源的拥有权会从被复制物转移到目标物。如条款13所述（auto_ptr)。</p>
<blockquote>
<ul>
<li>复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。</li>
<li>普遍而常见的RAII class copy行为是：抑制copying，实行引用计数法。不过其他行为也有可能被实现。</li>
</ul>
</blockquote>
<h5 id="15-在资源管理类中提供对原始资源的访问"><a href="#15-在资源管理类中提供对原始资源的访问" class="headerlink" title="15. 在资源管理类中提供对原始资源的访问"></a>15. 在资源管理类中提供对原始资源的访问</h5><p>完美的情况是依赖资源管理类来处理所有和资源之间的互动，而不是直接处理原始资源，但是很多接口都是直接处理原始资源，所以需要提供对原始资源的访问。</p>
<p>有两个方法可以达成目标：显示转换和隐式转换。</p>
<p>tr1::shared_ptr和auto_ptr都提供一个get成员函数，用来执行显式转换，也就是它会返回智能指针内部的原始指针（的复件）。</p>
<p>就像（几乎）所有智能指针一样，tr1::shared_ptr和auto_ptr也重载了指针取值操作符（operator-&gt;和operator*)，它们允许隐式转换至底部原始指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Investment</span> &#123;</span> <span class="comment">// investment继承体系的根类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isTaxFree</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>; <span class="comment">// factory函数</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pil</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> taxable1 = !(pil-&gt;<span class="built_in">isTaxFree</span>()); <span class="comment">// 经由operator-&gt;访问资源</span></span><br><span class="line">...</span><br><span class="line"><span class="function">std::auto_ptr&lt;Investment&gt; <span class="title">pi2</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> taxable2 = !((*pi2).<span class="built_in">isTaxFree</span>()); <span class="comment">// 经由operator*访问资源</span></span><br></pre></td></tr></table></figure>

<p>由于有时候还是必须取得RAII对象内的原始资源，某些RAII class 设计者提供一个隐式转换函数。考虑下面这个用于字体的RAII class：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FontHandle <span class="title">getFont</span><span class="params">()</span></span>; <span class="comment">// C API</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">releaseFont</span><span class="params">(FontHandle fh)</span></span>; <span class="comment">// 来自同一组C API</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span> &#123;</span> <span class="comment">// RAII class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Font</span><span class="params">(FontHandle fh)</span> <span class="comment">// 获得资源</span></span></span><br><span class="line"><span class="function">    : f(fh)</span></span><br><span class="line"><span class="function">    &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Font</span>() &#123; <span class="built_in">releaseFont</span>(f); &#125; <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="function">FontHandle <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> f; &#125; <span class="comment">// 显示转换函数</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> f; &#125; <span class="comment">// 隐式转换函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FontHandle f; <span class="comment">// 原始（raw)字体资源</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>APIs往往要求访问原始资源，所以每一个RAII class应该提供一个“取得其所管理的资源”的方法。</li>
<li>对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全，但隐式转换对用户比较方便。</li>
</ul>
</blockquote>
<h5 id="16-成对使用new-和delete时要采取相同的形式"><a href="#16-成对使用new-和delete时要采取相同的形式" class="headerlink" title="16. 成对使用new 和delete时要采取相同的形式"></a>16. 成对使用new 和delete时要采取相同的形式</h5><p>数组的delete需要使用delete[]。因为单一对象的内存布局一般而言不同于数组的内存布局。更明确的说，数组所用的内存通常还包括“数组大小”的记录，以便delete知道需要调用多少次析构函数。单一对象的内存则没有这笔记录。</p>
<p>这个规则对于喜欢用typedef的人也很重要，因为它意味着typedef的作者必须说清楚，当程序员以new创建该种类型对象时，该以哪一种delete形式删除之。考虑下面这个typedef：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::string AddressLines[<span class="number">4</span>] <span class="comment">//每个人的地址有4行，每行是一个string</span></span><br><span class="line">std::string pa1 = <span class="keyword">new</span> AddressLines; <span class="comment">// 注意，“new AddressLines&quot;返回一个string*</span></span><br><span class="line"><span class="comment">// 就像new string[4]一样</span></span><br><span class="line"><span class="comment">// 就必须匹配”数组形式“的delete：</span></span><br><span class="line"><span class="keyword">delete</span> pa1; <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">delete</span>[] pa1 <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>如果在new表达式中使用[], 必须在相应的delete表达式中也使用[]。如果在new表达式中不使用[],一定不要在相应的delete表达式中使用[]。</li>
</ul>
</blockquote>
<h5 id="17-以独立语句将newed对象置入智能指针"><a href="#17-以独立语句将newed对象置入智能指针" class="headerlink" title="17. 以独立语句将newed对象置入智能指针"></a>17. 以独立语句将newed对象置入智能指针</h5><p>假设我们有个函数用来揭示处理程序的优先权，另一个函数用来在某动态分配所得的Widget上进行某些带有优先权的处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(std::tr1::shared_ptr&lt;Widget&gt; pw, <span class="keyword">int</span> priority)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="built_in">processWidget</span>(std::tr1::shared_ptr&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>

<p>在调用processWidget之前，编译器必须创建代码，做以下三件事：</p>
<ul>
<li>调用priority</li>
<li>执行”new Widget”</li>
<li>调用tr1::shared_ptr构造函数</li>
</ul>
<p>C++编译器以什么顺序来完成这些事情？首先可以确定“new Widget”一定执行于tr1::shared_ptr构造函数之前，但是对priority的调用则可以排在第一或第二或第三执行。如果编译器选择以第二的顺序执行它，一旦priority的调用导致异常，在此情况下”new Widget“返回的指针将会遗失，因为它尚未被置入tr1::shared_ptr内。因为在”资源被创建“和”资源被转换为资源管理对象“两个时间点之间有可能发生异常干扰，从而导致内存泄漏。</p>
<p>避免这类问题的方法：使用分离语句，分别写出（1）创建Widget. (2) 将它置入一个智能指针内，然后再把那个智能指针传给processWidget:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span> <span class="comment">// 在单独语句内以智能指针存储newed所得对象</span></span></span><br><span class="line"><span class="function"><span class="title">processWidget</span><span class="params">(pw, priority())</span></span>; <span class="comment">// 这个动作不会造成内存泄漏</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>以独立语句将newed对象存储于(置入)智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的内存泄漏</li>
</ul>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/17/Effective-C-%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95-%E4%B8%89-13-17/" data-id="ckpkyp27w0003hd3a3fk8eg4i" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Effective-C/" rel="tag">Effective C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Effective-C-改善程序与设计的55个具体做法-二(5~12)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/05/Effective-C-%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95-%E4%BA%8C(5~12)/" class="article-date">
  <time datetime="2019-12-05T15:29:54.000Z" itemprop="datePublished">2019-12-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/05/Effective-C-%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95-%E4%BA%8C(5~12)/">Effective C++改善程序与设计的55个具体做法(5~12)(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="二、构造-析构-赋值运算"><a href="#二、构造-析构-赋值运算" class="headerlink" title="二、构造/析构/赋值运算"></a>二、构造/析构/赋值运算</h4><h5 id="5-了解C-默默编写并调用哪些函数"><a href="#5-了解C-默默编写并调用哪些函数" class="headerlink" title="5. 了解C++默默编写并调用哪些函数"></a>5. 了解C++默默编写并调用哪些函数</h5>
        
          <p class="article-more-link">
            <a href="/2019/12/05/Effective-C-%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95-%E4%BA%8C(5~12)/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/05/Effective-C-%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95-%E4%BA%8C(5~12)/" data-id="ckpkyp28o000xhd3aanlwgwi1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Effective-C/" rel="tag">Effective C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Effectiv-C-改善程序与设计的55个具体做法-一(1~4)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/26/Effectiv-C-%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95-%E4%B8%80(1~4)/" class="article-date">
  <time datetime="2019-11-25T16:49:41.000Z" itemprop="datePublished">2019-11-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/26/Effectiv-C-%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95-%E4%B8%80(1~4)/">Effectiv C++ 改善程序与设计的55个具体做法(1~4)(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="一、让自己习惯C"><a href="#一、让自己习惯C" class="headerlink" title="一、让自己习惯C++"></a>一、让自己习惯C++</h4><h5 id="1、-视C-为一个语言联邦"><a href="#1、-视C-为一个语言联邦" class="headerlink" title="1、 视C++为一个语言联邦"></a>1、 视C++为一个语言联邦</h5><p>可以将C++视为由C、Object-Oriented C++、Template C++、STL等次语言组成的联邦，当从一个次语言移往另一个次语言时，守则可能改变。</p>
        
          <p class="article-more-link">
            <a href="/2019/11/26/Effectiv-C-%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95-%E4%B8%80(1~4)/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/26/Effectiv-C-%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95-%E4%B8%80(1~4)/" data-id="ckpkyp27s0001hd3a6ge205h3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Effective-C/" rel="tag">Effective C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Ubuntu-18-04中配置java-JDK" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/23/Ubuntu-18-04%E4%B8%AD%E9%85%8D%E7%BD%AEjava-JDK/" class="article-date">
  <time datetime="2019-11-23T15:38:03.000Z" itemprop="datePublished">2019-11-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9D%82%E9%A1%B9/">杂项</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/23/Ubuntu-18-04%E4%B8%AD%E9%85%8D%E7%BD%AEjava-JDK/">Ubuntu 18.04中配置java JDK</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="安装oracle-jdk"><a href="#安装oracle-jdk" class="headerlink" title="安装oracle jdk"></a>安装oracle jdk</h4><p>下载所需的版本的JDK<a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/java/javase/downloads/jdk13-downloads-5672538.html">https://www.oracle.com/technetwork/java/javase/downloads/jdk13-downloads-5672538.html</a>,然后解压:</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">sudo</span></span> tar -zxvf jdk.....tar.gz</span><br></pre></td></tr></table></figure>
<p>解压出来的目录就是oracle版本的jdk安装目录</p>
<h4 id="切换jdk版本"><a href="#切换jdk版本" class="headerlink" title="切换jdk版本"></a>切换jdk版本</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">update</span>-alternatives <span class="comment">--config java</span></span><br></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/2019/11/23/Ubuntu-18-04%E4%B8%AD%E9%85%8D%E7%BD%AEjava-JDK/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/23/Ubuntu-18-04%E4%B8%AD%E9%85%8D%E7%BD%AEjava-JDK/" data-id="ckpkyp284000ahd3abc76eugq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">开发环境搭建</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-sublime-安装MarkDown插件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/23/sublime-%E5%AE%89%E8%A3%85MarkDown%E6%8F%92%E4%BB%B6/" class="article-date">
  <time datetime="2019-11-22T17:11:12.000Z" itemprop="datePublished">2019-11-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9D%82%E9%A1%B9/">杂项</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/23/sublime-%E5%AE%89%E8%A3%85MarkDown%E6%8F%92%E4%BB%B6/">sublime 安装MarkDown插件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="安装package-control"><a href="#安装package-control" class="headerlink" title="安装package control"></a>安装package control</h4><ul>
<li>Ctrl+Shift+p</li>
<li>输入install Package Control</li>
<li>Ctrl+Shif+p</li>
<li>输入pcip(选择 Package Control:Install Package)</li>
<li>输入mmp(选择 Markon real-time markdown preview)
        
          <p class="article-more-link">
            <a href="/2019/11/23/sublime-%E5%AE%89%E8%A3%85MarkDown%E6%8F%92%E4%BB%B6/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/23/sublime-%E5%AE%89%E8%A3%85MarkDown%E6%8F%92%E4%BB%B6/" data-id="ckpkyp288000ehd3a77awb6ur" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">开发环境搭建</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Computer-System/">Computer System</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E9%A1%B9/">杂项</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Computer-System/" rel="tag">Computer System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Effective-C/" rel="tag">Effective C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">开发环境搭建</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/Computer-System/" style="font-size: 10px;">Computer System</a> <a href="/tags/Effective-C/" style="font-size: 20px;">Effective C++</a> <a href="/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" style="font-size: 15px;">开发环境搭建</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/26/computer-system-%E4%B8%80/">computer system(一)</a>
          </li>
        
          <li>
            <a href="/2020/02/28/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9/">零散知识点</a>
          </li>
        
          <li>
            <a href="/2020/01/07/Effective-C-%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95_all/">Effective-C-改善程序与设计的55个具体做法(All)</a>
          </li>
        
          <li>
            <a href="/2020/01/05/Effective-C-%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95%E4%BA%94-26-31/">Effective-C-改善程序与设计的55个具体做法(五)(26~31)</a>
          </li>
        
          <li>
            <a href="/2019/12/17/Effective-C-%E6%94%B9%E5%96%84%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%9A%8455%E4%B8%AA%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95-%E5%9B%9B-18-25/">Effective-C-改善程序与设计的55个具体做法(四)(18~25)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 可乐<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>